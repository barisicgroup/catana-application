function runTests() {
    const header = document.createElement("div");
    header.className = "test-window-header";
    const headerText = document.createElement("span");
    headerText.textContent = "Tests";
    const headerCloseButton = document.createElement("button");
    headerCloseButton.textContent = "X";
    headerCloseButton.addEventListener("click", () => window.remove());
    header.appendChild(headerText);
    header.appendChild(headerCloseButton);

    const content = document.createElement("div");
    content.className = "test-window-content";

    const window = document.createElement("div");
    window.className = "test-window";
    window.appendChild(header);
    window.appendChild(content);

    (async() => {
        const context = await WG.WgContext.get("timestamp-query");
        const outputs = [
            /*_runTest(context, test_set, "SET (shader) 10 values", [10]),
            _runTest(context, test_set, "SET (shader) 1.000.000 values", [1000000]),
            _runTest(context, test_gridAssignAndReassign, "GRID ASSIGN (shader)"),
            _runTest(context, test_scan, "SCAN (shader) (prefix sum) with 16 values", [16]),
            _runTest(context, test_scan, "SCAN (shader) (prefix sum) with 17 values", [17]),
            _runTest(context, test_scan, "SCAN (shader) (prefix sum) with 27 values", [27]),
            _runTest(context, test_scan, "SCAN (shader) (prefix sum) with 32 values", [32]),
            _runTest(context, test_add, "ADD (shader)"),
            _runTest(context, test_scanAlgorithm, "SCAN (algorithm) (prefix sum)", []),
            _runTest(context, test_gridAssignScan, "TEST GRID ASSIGN -> SCAN", []),
            _runTest(context, test_sort_seq, "TEST SEQUENTIAL SCAN", []),
            _runTest(context, test_sort_gpu, "TEST SORT (shader)", []),
            _runTest(context, test_map_xyz, "TEST MAP XYZ (shader)", []),
            _runTest(context, test_collision_global, "TEST COLLISION GLOBAL (shader)", []),
            _runTest(context, test_bitArray, "TEST BIT ARRAY", []),
            _runTest(context, test_collision_global_algorithm, "TEST COLLISION GLOBAL (algorithm)", []),
            _runTest(context, test_unsort, "TEST UNSORT (shader)", []),
            _runTest(context, test_collision_algorithm, "TEST ALGORITHM (ULTIMATE) (algorithm)", []),
            _runTest(context, test_performance, "TEST PERFORMANCE", [500, 10000, 100000, 1000000, 10000000]),*/
            _runTest(context, test_rendering, "TEST RENDERING", [])
        ];
        for (const o of outputs) content.appendChild(o);
    })();

    return window;
}

function _runTest(context, test, testName, args) {
    const div = document.createElement("div");
    div.className = "test";
    const divText = document.createElement("span");
    divText.textContent = testName + " (running...)";
    const divLoading = document.createElement("span");
    divLoading.className = "loading";
    div.appendChild(divText);
    div.appendChild(divLoading);

    const visContainer = (text, collapsed=false) => {
        const visElem = document.createElement("div");
        visElem.className = "vis-container test log";
        const visHeader = document.createElement("div");
        visHeader.className = "vis-header";
        const visText = document.createElement("span");
        visText.textContent = text;
        const visButton = document.createElement("button");
        const visContent = document.createElement("div");
        visContent.className = "vis-content";

        const toggle = () => {
            collapsed = !collapsed;
            visButton.textContent = collapsed ? "+" : "â€“";
            if (collapsed) visContent.classList.add("invisible");
            else visContent.classList.remove("invisible");
        };
        collapsed = !collapsed;
        toggle();
        visButton.addEventListener("click", toggle);

        visHeader.appendChild(visText);
        visHeader.appendChild(visButton);
        visElem.appendChild(visHeader);
        visElem.appendChild(visContent);

        return {
            dom: visElem,
            content: visContent
        };
    };

    let allPassed = true;
    const t = {
        log: (text, passed) => {
            const logElem = document.createElement("div");
            logElem.textContent = text;
            div.appendChild(logElem);
            let className = "test ";
            if (passed === undefined) className += "log";
            else className += (passed ? "passed" : "failed");
            logElem.className = className;
        },
        test: (passed, text) => {
            const testElem = document.createElement("div");
            testElem.className = "test " + (passed ? "passed" : "failed");
            testElem.textContent = text + ": " + (passed ? "PASSED" : "FAILED");
            div.appendChild(testElem);
            allPassed = allPassed && passed;
        },
        show: (text, element) => {
            const vis = visContainer(text, true);
            vis.content.appendChild(element);
            div.appendChild(vis.dom);
        },
        array: (data, text) => {
            //const vis = visContainer(text);
            const array = new VisArray(data);
            //vis.content.appendChild(array.container);
            //div.appendChild(vis.dom);
            const vis = document.createElement("div");
            vis.className = "vis-container test log";
            const header = document.createElement("span");
            header.className = "vis-header";
            header.textContent = text;
            vis.appendChild(header);
            vis.appendChild(array.container);
            div.appendChild(vis);
        },
        matrix: (data, shape, text) => {
            const vis = visContainer(text, true);
            const matrix = new VisMatrix(data, shape, 10, 10);
            const controls = document.createElement("div");
            controls.className = "vis-matrix-controls";
            const feedbackText = document.createElement("div");
            feedbackText.className = "vis-matrix-text";
            const reduceContainer = document.createElement("div");
            const reduce = document.createElement("input");
            reduce.type = "checkbox"
            reduce.name = "checkbox" + id();
            reduce.id = reduce.name;
            reduce.checked = matrix.reduce;
            const reduceLabel = document.createElement("label");
            reduceLabel.setAttribute("for", reduce.name);
            reduceLabel.textContent = "Reduce";
            const slider = document.createElement("input");
            slider.className = "vis-matrix-slider";
            slider.type = "range";
            const extent = matrix.layerExtent;
            if (extent[0] === 0 && extent[1] === 0) {
                slider.className += " invisible";
                reduceLabel.className += " invisible";
                reduce.className += " invisible";
            }
            slider.setAttribute("orient", "vertical");
            slider.min = extent[0];
            slider.max = extent[1];
            slider.step = 1;
            slider.value = matrix.layer;
            slider.disabled = matrix.reduce;
            const container = document.createElement("div");
            container.className = "vis-matrix-container";

            const updateFeedbackText = (d) => {
                if (!d) {
                    feedbackText.textContent = "z: " + matrix.layer;
                    return;
                }
                if (matrix.reduce) {
                    feedbackText.textContent =
                        "x,y: " + d.x + ", " + d.y + "\n" +
                        "Value: " + d.sum;
                    return;
                }
                feedbackText.textContent =
                    //"Index: " + d.i + "\n" +
                    "x,y,z: " + d.x + ", " + d.y + ", " + matrix.layer + "\n" +
                    "Value: " + d.z_array[matrix.layer];
            }
            updateFeedbackText();
            matrix.addOnHoverFun(updateFeedbackText);

            slider.addEventListener("input", () => {
                matrix.layer = slider.value;
                updateFeedbackText();
            });

            reduce.addEventListener("click", () => {
                matrix.reduce = reduce.checked;
                slider.disabled = reduce.checked;
            });

            reduceContainer.appendChild(reduce);
            reduceContainer.appendChild(reduceLabel);
            controls.appendChild(feedbackText);
            controls.appendChild(reduceContainer);
            controls.appendChild(slider);
            container.appendChild(matrix.container);
            container.appendChild(controls);
            vis.content.appendChild(container);
            div.appendChild(vis.dom);
        },
        render: (xyzcBuffer) => {
            const vis = visContainer("Rendering");
            const canvas = document.createElement("canvas");
            vis.content.appendChild(canvas);
            div.appendChild(vis.dom);
            renderPoints(canvas, xyzcBuffer);
        }
    };

    (async() => {
        //const startTime = performance.now();
        await test(t, context, args);
        //const endTime = performance.now();
        divLoading.remove();
        divText.textContent = testName;
        //t.log("Finished in " + (endTime - startTime) + " ms: " + (allPassed ? " ALL PASSED" : " NOT ALL PASSED"), allPassed);
        t.log("Finished: " + (allPassed ? " ALL PASSED" : " NOT ALL PASSED"), allPassed);
    })();

    return div;
}

function formatArray(a, max=20) {
    if (a.length <= max) return a.toString() + " (" + a.length + ")";
    const firstElems = new Array(max);
    for (let i = 0; i < firstElems.length; ++i) firstElems[i] = a[i];
    return firstElems.join(",") + ", ... (" + a.length + ")";
}

function formatVectors(x, y, z, max=5) {
    const pointsAsStrings = y === undefined || z === undefined
        ? x.map(v => "(" + v.join(",") + ")")
        : x.map((v,i) => "(" + x + "," + y[i] + "," + z[i] + ")");
    const length = "(" + x.length + ")";
    return x.length <= max
        ? pointsAsStrings.join(",") + " " + length
        : pointsAsStrings.slice(0, max).join(",") + " ... " + length;
}

async function debugAndDelete(t, debug) {
    if (debug === undefined) return;
    let i = 0;
    const outputs = WG.WgPass.getOutputs(debug);
    if (!outputs) return;
    for (const o of outputs) {
        const array = await o.read();
        const shape = "(" + o.shape[0] + "," + o.shape[1] + "," + o.shape[2] + ")";
        const text = "(" + i + ") Debug output; name=" + o.name + "; shape=" + shape + "; ";
        //t.log(text + " data=" + formatArray(array, Infinity));
        t.array(array, text);
        ++i;
    }
    WG.WgPass.deleteOutputs(debug);
}

function createComponents() {
    const c1Box = { min: new WG.Vector3(2, 2, 2), max: new WG.Vector3(14, 2, 2) };
    const c2Box = { min: new WG.Vector3(3, 1, 2), max: new WG.Vector3(7, 4, 2) };
    const matrix = (elements) => {
        return {
            elements: elements,
            clone: () => matrix(elements.slice())
        };
    };
    return [
        {
            name: "Component 1",
            matrix: matrix([ 1, 0, 0, 0, // Transposed :)
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     2, 2, 2, 1 ]),
            elems: [
                [0, 0, 0],
                [1, 0, 0], // (3,2,2) -> Collision on i=1!
                [2, 0, 0], // (4,2,2) -> Collision on i=2!
                [3, 0, 0],
                [10, 0, 0],
                [11, 0, 0],
                [12, 0, 0]
            ],
            getBox: () => c1Box
        },
        { // Component 2
            name: "Component 2",
            matrix: matrix([ 1,  0, 0, 0,
                                     0,  1, 0, 0,
                                     0,  0, 1, 0,
                                     0, -4, 0, 1]),
            elems: [
                [3, 5, 2],
                [3, 6, 2], // (3,2,2) -> Collision on i=8!
                [3, 7, 2],
                [4, 5, 2],
                [4, 6, 2], // (4,2,2) -> Collision on i=10!
                [4, 7, 2],
                [4, 8, 2],
                [5, 7, 2],
                [5, 8, 2],
                [6, 8, 2],
                [7, 8, 2]  // Final elem, i=17
            ],
            getBox: () => c2Box
        }
    ];
}

function createData(components) {
    const elems = components.map(v => v.elems).reduce((a, b) => a.concat(b));

    const elemRadius = 0.5;
    const elemDiameter = elemRadius * 2;
    const gridBinSize = new WG.Vector3(elemDiameter, elemDiameter, elemDiameter); // TODO make customizable?
    const gridMin = components.map(v => v.getBox().min).reduce((a,b) => a.min(b));
    const gridMax = components.map(v => v.getBox().max).reduce((a,b) => a.max(b)).add(new WG.Vector3(1, 1, 1));
    const gridShape = gridMax.clone().sub(gridMin).divide(gridBinSize).ceil();
    const gridSize = gridShape.x * gridShape.y * gridShape.z;

    const expected = {
        perBin_elemCount: new Uint32Array([0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1,
            0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]),
        bin_maxElemCount: 2,
        perElem_binId: new Uint32Array([13, 14, 15, 16, 23, 24, 25,
            1, 14, 27, 2, 15, 28, 41, 29, 42, 43, 44]),
        perBin_elemCount_scan: new Uint32Array([0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 3, 5, 7, 8, 8, 8, 8, 8, 8, 8, 9, 10,
            11,11,12,13,14,14,14,14,14,14,14,14,14,
            14,14,14,15,16,17,18,18,18,18,18,18,18]),
        elems_sortedByBinId: [
            [3, 1, 2],  // Component 1
            [4, 1, 2],  // Component 1
            [2, 2, 2],  // Component 0
            [3, 2, 2],  // Component 0 or 1
            [3, 2, 2],  // Component 1 or 0
            [4, 2, 2],  // Component 0 or 1
            [4, 2, 2],  // Component 1 or 0
            [5, 2, 2],  // Component 0
            [12,2, 2],  // Component 0
            [13,2, 2],  // Component 0
            [14,2, 2],  // Component 0
            [3, 3, 2],  // Component 1
            [4, 3, 2],  // Component 1
            [5, 3, 2],  // Component 1
            [4, 4, 2],  // Component 1
            [5, 4, 2],  // Component 1
            [6, 4, 2],  // Component 1
            [7, 4, 2]], // Component 1
        elems_collisions_sorted: WG.BitArray.convert([0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    };

    const xyzc = [
        // Component 0
        [2, 2, 2, 0], [3, 2, 2, 0], [4, 2, 2, 0], [5, 2, 2, 0], [12, 2, 2, 0], [13, 2, 2, 0], [14, 2, 2, 0],
        // Component 1
        [3, 1, 2, 1], [3, 2, 2, 1], [3, 3, 2, 1], [4, 1, 2, 1], [4, 2, 2, 1], [4, 3, 2, 1], [4, 4, 2, 1], [5, 3, 2, 1],
        [5, 4, 2, 1], [6, 4, 2, 1], [7, 4, 2, 1]
    ];

    const xyzc_sorted = [
        [3, 1, 2, 1],  // Component 1
        [4, 1, 2, 1],  // Component 1
        [2, 2, 2, 0],  // Component 0
        [3, 2, 2, 1],  // Component 0 or 1
        [3, 2, 2, 0],  // Component 1 or 0
        [4, 2, 2, 0],  // Component 0 or 1
        [4, 2, 2, 1],  // Component 1 or 0
        [5, 2, 2, 0],  // Component 0
        [12,2, 2, 0],  // Component 0
        [13,2, 2, 0],  // Component 0
        [14,2, 2, 0],  // Component 0
        [3, 3, 2, 1],  // Component 1
        [4, 3, 2, 1],  // Component 1
        [5, 3, 2, 1],  // Component 1
        [4, 4, 2, 1],  // Component 1
        [5, 4, 2, 1],  // Component 1
        [6, 4, 2, 1],  // Component 1
        [7, 4, 2, 1] // Component 1
    ];

    return {
        elems: elems,
        transformedElems: xyzc.map(v => v.slice(0, 3)),
        xyzc: xyzc,
        xyzc_sorted: xyzc_sorted,

        gridBinSize: gridBinSize,
        gridMin: gridMin,
        gridMax: gridMax,
        gridShape: gridShape,
        gridSize: gridSize,
        elemRadius: elemRadius,

        expected: expected
    }
}

function createFfrnnData(context, components, output=false) {
    const data = createData(components);

    const in_perComp_matrix = components
        .map(v => v.matrix.elements)
        .reduce((a, b) => a.concat(b));

    const in_perElem_xyzcr = data.xyzc
        .map(v => [v[0], v[1], v[2], (v[3] << 16) | 50])
        .reduce((a,b) => a.concat(b));

    const uniforms = {
        gridMin: data.gridMin,
        gridMax: data.gridMax,
        gridBinSize: data.gridBinSize,
        elemRadius: 0.5
    };

    const b = [
        // Input
        WG.WgBuffer.createStorage(context, [in_perComp_matrix.length, 1, 1], Float32Array, new Float32Array(in_perComp_matrix)),
        WG.WgBuffer.createStorage(context, [in_perElem_xyzcr.length, 1, 1], Float32Array, new Float32Array(in_perElem_xyzcr)),
        // Output src
        WG.WgBuffer.createEmptyStorage(context, [data.gridSize, 1, 1], Uint32Array, [WG.BufferFeature.COPIABLE]),
        WG.WgBuffer.createEmptyStorage(context, [data.xyzc.length, 1, 1], Uint32Array, [WG.BufferFeature.COPIABLE]),
        // Output dst
        output ? WG.WgBuffer.createOutput(context, [data.gridSize, 1, 1], Uint32Array) : undefined,
        output ? WG.WgBuffer.createOutput(context, [data.xyzc.length, 1, 1], Uint32Array) : undefined
    ];

    const in_buffers = {
        in_perComp_matrix: b[0],
        in_perElem_xyzcr: b[1],
        out_perBin_elemCount: b[2],
        out_perElem_binId: b[3]
    };

    const out_buffers = {
        perBin_elemCount: b[4],
        perElem_binId: b[5]
    };

    return {
        transformedElems: data.transformedElems,
        xyzc: data.xyzc,

        in_buffers: in_buffers,
        out_buffers: out_buffers,
        uniforms: uniforms,
        expected: data.expected,

        gridShape: data.gridShape,
        gridSize: data.gridSize
    };
}

function data_1bna() {
    return {
        x: new Float32Array([18.934999465942383,19.1299991607666,19.961000442504883,19.360000610351562,20.172000885009766,21.350000381469727,18.947999954223633,19.231000900268555,18.06999969482422,18.224000930786133,19.360000610351562,17.14299964904785,15.916999816894531,14.82800006866455,15.718999862670898,16.843000411987305,22.409000396728516,23.535999298095703,21.82200050354004,22.84000015258789,23.542999267578125,23.493999481201172,22.19300079345703,23.69300079345703,24.722999572753906,22.273000717163086,21.72100067138672,20.23699951171875,19.525999069213867,18.207000732421875,18.08300018310547,16.90399932861328,15.73900032043457,17.19700050354004,18.43400001525879,18.507999420166016,19.53700065612793,19.290000915527344,25.06399917602539,26.506000518798828,24.55900001525879,24.260000228881836,24.583999633789062,23.523000717163086,22.256000518798828,23.423999786376953,24.121000289916992,21.93000030517578,21.277999877929688,20.195999145507812,18.909000396728516,18.684999465942383,17.934999465942383,18.216999053955078,17.22100067138672,19.525999069213867,20.53700065612793,24.249000549316406,25.420000076293945,24.20800018310547,22.930999755859375,22.714000701904297,21.39299964904785,20.35300064086914,21.263999938964844,20.284000396728516,20.792999267578125,19.715999603271484,19.30500030517578,20.017000198364258,19.312999725341797,18.121000289916992,16.95199966430664,16.768999099731445,15.932999610900879,15.972000122070312,14.831000328063965,17.06800079345703,18.083999633789062,20.356000900268555,21.115999221801758,20.836999893188477,18.809999465942383,18.014999389648438,16.672000885009766,16.841999053955078,16.018999099731445,14.76200008392334,15.95199966430664,15.85099983215332,16.391000747680664,17.658000946044922,17.863000869750977,16.67300033569336,16.229999542236328,17.045000076293945,14.965999603271484,14.178000450134277,14.463000297546387,15.75,13.866000175476074,13.027999877929688,14.71500015258789,12.878999710083008,11.802000045776367,11.111000061035156,12.152000427246094,10.416999816894531,9.006999969482422,11.239999771118164,11.699000358581543,12.918000221252441,14.114999771118164,15.048999786376953,14.416000366210938,14.873000144958496,16.160999298095703,13.99899959564209,12.753000259399414,12.210000038146973,13.116000175476074,8.081000328063965,6.668000221252441,8.600000381469727,8.23900032043457,7.9070000648498535,8.161999702453613,9.543000221252441,7.460999965667725,6.250999927520752,8.531999588012695,9.644000053405762,11.020999908447266,11.821999549865723,11.383000373840332,13.119000434875488,13.633000373840332,14.829999923706055,12.781000137329102,13.269000053405762,11.46500015258789,5.383999824523926,4.025000095367432,5.458000183105469,6.085999965667725,6.145999908447266,6.994999885559082,8.187999725341797,6.418000221252441,5.9670000076293945,7.513000011444092,8.736000061035156,9.822999954223633,11.086000442504883,11.324000358581543,12.093999862670898,11.87600040435791,12.857999801635742,10.569000244140625,10.26099967956543,9.545000076293945,5.531000137329102,4.6479997634887695,5.010000228881836,6.926000118255615,7.636000156402588,8.897000312805176,9.637999534606934,8.717000007629395,9.470000267028809,9.12600040435791,10.241000175476074,10.52400016784668,11.814000129699707,12.690999984741211,12.105999946594238,11.140999794006348,11.461000442504883,9.803000450134277,9.49899959564209,9.055000305175781,9.496000289916992,7.631999969482422,9.954000473022461,11.381999969482422,11.972000122070312,11.802000045776367,11.32699966430664,12.310999870300293,10.413999557495117,11.428999900817871,10.890000343322754,9.616000175476074,9.541000366210938,10.817999839782715,11.37600040435791,10.812999725341797,12.729000091552734,13.498000144958496,14.833999633789062,12.982000350952148,11.656000137329102,12.762999534606934,12.795999526977539,11.88599967956543,14.272000312805176,15.274999618530273,16.222000122070312,15.442999839782715,16.941999435424805,18.34000015258789,16.118000030517578,15.855999946594238,14.67199993133545,14.802000045776367,15.923999786376953,13.722999572753906,12.515000343322754,11.40999984741211,12.347999572753906,13.470000267028809,19.33099937438965,20.70400047302246,18.76300048828125,19.302000045776367,20.108999252319336,19.74799919128418,18.350000381469727,19.92099952697754,20.985000610351562,18.53499984741211,17.96500015258789,16.493000030517578,15.663000106811523,14.368000030517578,14.387999534606934,13.300999641418457,12.090999603271484,13.75,15.041999816894531,15.258999824523926,16.06100082397461,15.65999984741211,7.458000183105469,8.251999855041504,9.71399974822998,10.144000053405762,10.102999687194824,11.293000221252441,10.253999710083008,10.895999908447266,10.574999809265137,11.559000015258789,12.725000381469727,11.246000289916992,9.979999542236328,9.697999954223633,8.939000129699707,9.265000343322754,11.60200023651123,11.666000366210938,10.644000053405762,13.050999641418457,14.100000381469727,15.11299991607666,14.555999755859375,15.444999694824219,16.836000442504883,14.937000274658203,15.057999610900879,14.03600025177002,12.710000038146973,12.015999794006348,12.937000274658203,12.76099967956543,11.722999572753906,13.95199966430664,15.170999526977539,16.243999481201172,15.329000473022461,14.178999900817871,17.47800064086914,18.665000915527344,16.427000045776367,17.957000732421875,18.96299934387207,18.93600082397461,17.591999053955078,19.253000259399414,20.659000396728516,18.520000457763672,17.545000076293945,16.145000457763672,15.506999969482422,16.16200065612793,14.208999633789062,13.53600025177002,12.204999923706055,14.163999557495117,15.508999824523926,21.304000854492188,22.695999145507812,20.488000869750977,21.305999755859375,22.177000045776367,21.73900032043457,20.30500030517578,22.10099983215332,22.591999053955078,20.81999969482422,19.764999389648438,18.51300048828125,18.363000869750977,17.079999923706055,16.399999618530273,14.996000289916992,14.081999778747559,14.711999893188477,15.605999946594238,15.133999824523926,16.91200065612793,17.236000061035156,22.90399932861328,23.993999481201172,23.104000091552734,21.57699966430664,21.215999603271484,20.10099983215332,18.913000106811523,20.347000122070312,19.73200035095215,19.75200080871582,18.496999740600586,18.07900047302246,18.847000122070312,18.11400032043457,16.841999053955078,15.57699966430664,15.447999954223633,14.482000350952148,14.597000122070312,15.699999809265137,16.791000366210938,19.80299949645996,19.79599952697754,20.952999114990234,18.395999908447266,17.202999114990234,16.03499984741211,15.855999946594238,16.10099983215332,14.890000343322754,16.368000030517578,15.560999870300293,16.104000091552734,17.410999298095703,17.538999557495117,16.266000747680664,15.71500015258789,16.482999801635742,14.388999938964844,13.63599967956543,14.019000053405762,15.366999626159668,14.604000091552734,13.791999816894531,15.85200023651123,13.633000373840332,12.39799976348877,11.809000015258789,12.767000198364258,11.515000343322754,10.102999687194824,12.267000198364258,12.425999641418457,13.609000205993652,13.442000389099121,12.310999870300293,14.550999641418457,15.8149995803833,16.7549991607666,15.972000122070312,17.344999313354492,14.843999862670898,9.512999534606934,8.145000457763672,10.454999923706055,9.395000457763672,8.576000213623047,8.654999732971191,10.003000259399414,8.272000312805176,7.198999881744385,9.586000442504883,10.1899995803833,11.65999984741211,12.256999969482422,11.583000183105469,13.619999885559082,14.402000427246094,15.625,13.77400016784668,14.562999725341797,12.385000228881836,6.593999862670898,5.169000148773193,6.869999885559082,7.408999919891357,7.330999851226807,8.100000381469727,9.477999687194824,7.765999794006348,7.035999774932861,9.123000144958496,10.107000350952148,11.32800006866455,12.534000396728516,12.5600004196167,13.638999938964844,13.5600004196167,14.6850004196167,12.338000297546387,11.192999839782715,6.508999824523926,5.38700008392334,6.235000133514404,7.767000198364258,8.215999603271484,9.42199993133545,10.493000030517578,9.267000198364258,10.088000297546387,9.75100040435791,10.98799991607666,11.598999977111816,11.036999702453613,11.920999526977539,13.071999549865723,14.369999885559082,14.746999740600586,15.267999649047852,15.02299976348877,16.06599998474121,13.8149995803833,12.902000427246094,9.47700023651123,8.767000198364258,8.670000076293945,10.807000160217285,11.687999725341797,13.114999771118164,13.284000396728516,13.440999984741211,14.340999603271484,13.928000450134277,14.312000274658203,14.144000053405762,15.199000358581543,16.256999969482422,15.067000389099121,13.89799976348877,13.770999908447266,12.795000076293945,12.9350004196167,14.657999992370605,14.86299991607666,13.633000373840332,16.033000946044922,17.243000030517578,18.20800018310547,17.715999603271484,18.229999542236328,18.97800064086914,18.885000228881836,18.275999069213867,17.163999557495117,15.87399959564209,15.128999710083008,15.989999771118164,15.765000343322754,14.718999862670898,16.926000595092773,18.156999588012695,19.20800018310547,18.350000381469727,17.231000900268555,19.736000061035156,10.878999710083008,18.31999969482422,9.821000099182129,8.914999961853027,17.5049991607666,28.496000289916992,11.345999717712402,9.097999572753906,16.488000869750977,22.077999114990234,7.132999897003174,14.095000267028809,27.163999557495117,15.295000076293945,18.18000030517578,6.216000080108643,7.054999828338623,12.454000473022461,11.491999626159668,14.220000267028809,6.138000011444092,17.315000534057617,18.951000213623047,20.459999084472656,3.5290000438690186,16.222999572753906,12.98900032043457,17.510000228881836,25.37700080871582,13.609999656677246,18.011999130249023,8.722999572753906,18.77899932861328,12.22700023651123,12.291999816894531,20.170000076293945,14.354000091552734,9.86400032043457,19.525999069213867,25.753999710083008,7.478000164031982,9.01200008392334,10.152000427246094,7.763999938964844,13.23900032043457,12.60099983215332,10.4399995803833,16.979000091552734,4.794000148773193,4.208000183105469,6.361999988555908,7.688000202178955,18.378999710083008,26.464000701904297,11.013999938964844,9.47599983215332,5.521999835968018,18.45599937438965,22.610000610351562,24.406999588012695,7.98799991607666,14.213000297546387,19.10099983215332,12.607000350952148,15.062000274658203,16.3799991607666,14.059000015258789,9.61299991607666,25.275999069213867,2.621999979019165,19.701000213623047,19.726999282836914,17.240999221801758,26.545000076293945,9.696999549865723,14.291999816894531,9.395999908447266,19.98699951171875,18.691999435424805]),
        y: new Float32Array([34.19499969482422,33.92100143432617,32.667999267578125,31.58300018310547,32.12200164794922,31.325000762939453,31.222999572753906,30.48200035095215,29.660999298095703,28.45400047302246,28.013999938964844,27.76099967956543,28.22599983215332,27.476999282836914,29.441999435424805,30.17099952697754,31.285999298095703,32.15700149536133,31.458999633789062,29.750999450683594,29.174999237060547,27.708999633789062,27.25200080871582,27.325000762939453,26.31999969482422,26.885000228881836,26.304000854492188,26.469999313354492,27.583999633789062,27.454999923706055,26.211999893188477,25.524999618530273,25.916000366210938,24.27899932861328,23.716999053955078,22.45599937438965,24.360000610351562,25.5939998626709,25.621000289916992,25.31599998474121,26.41200065612793,24.246000289916992,23.28499984741211,22.232999801635742,22.8439998626709,21.55699920654297,20.30900001525879,21.4060001373291,21.965999603271484,22.888999938964844,22.583999633789062,21.511999130249023,23.44700050354004,24.60300064086914,25.499000549316406,24.94499969482422,24.04800033569336,19.41200065612793,18.53499984741211,20.29599952697754,18.53700065612793,17.625,16.959999084472656,17.95199966430664,16.229000091552734,15.21399974822998,17.368000030517578,17.900999069213867,19.2810001373291,20.26300048828125,21.393999099731445,21.100000381469727,21.90399932861328,23.05699920654297,21.214000701904297,19.93000030517578,19.416000366210938,19.179000854492188,19.825000762939453,13.968999862670898,12.890999794006348,14.42300033569336,13.581000328063965,13.569000244140625,14.088000297546387,15.446999549865723,13.392999649047852,12.795999526977539,14.498000144958496,15.732000350952148,16.916000366210938,17.10300064086914,18.34600067138672,18.952999114990234,20.27899932861328,21.222000122070312,20.577999114990234,19.652000427246094,18.392000198364258,18.110000610351562,12.005999565124512,11.038999557495117,11.49899959564209,13.111000061035156,13.597000122070312,14.602999687194824,15.460000038146973,14.069999694824219,14.369000434875488,14.692000389099121,15.973999977111816,16.525999069213867,15.89900016784668,16.714000701904297,17.900999069213867,19.187000274658203,19.417999267578125,20.19099998474121,19.961999893188477,18.823999404907227,17.822999954223633,14.050000190734863,13.960000038146973,12.894000053405762,15.38700008392334,16.635000228881836,17.628000259399414,17.579999923706055,17.284000396728516,18.034000396728516,17.527000427246094,18.208999633789062,17.902999877929688,18.92300033569336,20.07699966430664,18.641000747680664,17.371999740600586,17.222000122070312,16.325000762939453,14.902000427246094,16.615999221801758,17.989999771118164,18.444000244140625,16.667999267578125,19.118000030517578,20.47800064086914,21.229000091552734,20.45800018310547,21.332000732421875,22.66699981689453,20.718000411987305,20.854999542236328,19.875999450683594,20.31599998474121,21.516000747680664,19.402999877929688,18.059999465942383,17.316999435424805,17.611000061035156,16.139999389648438,18.54800033569336,23.070999145507812,24.243999481201172,21.905000686645508,23.547000885009766,24.62700080871582,24.85300064086914,23.62700080871582,25.239999771118164,26.413999557495117,23.96500015258789,23.482999801635742,22.02199935913086,21.60300064086914,22.44700050354004,20.297000885009766,19.395000457763672,18.075000762939453,19.774999618530273,21.132999420166016,27.33300018310547,28.716999053955078,27.106000900268555,26.764999389648438,26.940000534057617,26.09000015258789,24.724000930786133,26.17799949645996,26.09600067138672,24.961999893188477,24.027999877929688,22.71299934387207,22.315000534057617,21.009000778198242,20.58799934387207,19.29199981689453,18.25200080871582,19.298999786376953,20.364999771118164,20.16900062561035,21.572999954223633,21.60099983215332,27.42099952697754,28.57200050354004,27.54199981689453,27.086000442504883,27.107999801635742,25.945999145507812,24.753999710083008,25.82699966430664,25.51099967956543,24.767000198364258,23.836000442504883,22.975000381469727,21.628000259399414,21.17799949645996,20.841999053955078,21.37299919128418,20.573999404907227,22.743999481201172,23.558000564575195,25.77400016784668,25.97599983215332,26.85099983215332,24.41200065612793,23.284000396728516,22.16699981689453,21.9689998626709,22.40399932861328,21.635000228881836,22.062000274658203,21.200000762939453,21.219999313354492,22.288999557495117,21.95800018310547,20.639999389648438,19.742000579833984,19.966999053955078,18.465999603271484,18.042999267578125,16.716999053955078,18.885000228881836,20.1560001373291,11.883999824523926,10.968000411987305,11.140999794006348,12.454999923706055,10.98900032043457,10.220999717712402,12.437000274658203,13.043999671936035,14.487000465393066,15.430000305175781,15.065999984741211,16.714000701904297,17.08799934387207,18.395000457763672,16.16200065612793,14.824000358581543,9.510000228881836,8.031999588012695,10.010000228881836,10.093999862670898,10.020999908447266,10.991999626159668,12.300000190734863,10.805999755859375,10.5600004196167,12.100000381469727,13.086000442504883,14.140000343322754,13.956999778747559,15.102999687194824,16.041000366210938,17.451000213623047,18.111000061035156,18.07900047302246,17.485000610351562,18.29199981689453,16.160999298095703,15.49899959564209,10.380000114440918,9.515999794006348,9.9399995803833,11.864999771118164,12.531000137329102,13.958000183105469,14.409000396728516,14.138999938964844,14.218999862670898,15.416999816894531,15.60200023651123,15.696000099182129,16.88599967956543,17.84600067138672,16.982999801635742,15.918999671936035,16.017000198364258,14.689000129699707,14.583999633789062,14.529000282287598,14.086999893188477,13.954000473022461,16.117000579833984,16.875999450683594,18.29199981689453,18.225000381469727,18.958999633789062,20.292999267578125,18.82900047302246,18.985000610351562,18.298999786376953,17.062000274658203,16.743999481201172,17.832000732421875,18.09000015258789,17.378000259399414,19.349000930786133,20.26799964904785,21.493000030517578,20.017000198364258,18.79400062561035,21.238000869750977,22.183000564575195,20.389999389648438,22.10700035095215,22.83300018310547,23.788000106811523,23.054000854492188,24.743000030517578,26.010000228881836,23.94499969482422,23.39299964904785,22.094999313354492,21.020000457763672,19.983999252319336,20.423999786376953,19.816999435424805,18.53700065612793,20.55699920654297,21.801000595092773,22.472000122070312,21.70599937438965,27.141000747680664,28.47800064086914,26.857999801635742,26.93899917602539,27.027999877929688,26.95800018310547,25.61199951171875,27.861000061035156,28.607999801635742,26.8439998626709,25.655000686645508,24.37299919128418,23.966999053955078,22.70599937438965,22.30900001525879,21.072999954223633,19.993999481201172,20.993999481201172,22.041000366210938,23.233999252319336,23.291000366210938,29.545000076293945,30.695999145507812,29.836000442504883,28.628000259399414,28.17099952697754,27.216999053955078,26.18400001525879,27.82200050354004,27.95199966430664,26.9060001373291,25.645000457763672,24.850000381469727,23.575000762939453,23.10099983215332,22.825000762939453,23.320999145507812,22.56999969482422,24.64699935913086,25.23900032043457,25.405000686645508,28.533000946044922,29.006999969482422,29.51300048828125,27.222999572753906,26.148000717163086,25.059999465942383,24.614999771118164,25.47100067138672,24.656999588012695,25.30699920654297,24.148000717163086,24.06999969482422,22.8799991607666,21.865999221801758,22.82900047302246,23.913999557495117,23.763999938964844,25.125999450683594,26.357999801635742,25.187000274658203,24.822999954223633,24.423999786376953,26.18899917602539,23.731000900268555,22.351999282836914,21.597999572753906,21.902000427246094,22.045000076293945,21.041000366210938,22.413999557495117,21.743000030517578,22.555999755859375,21.93899917602539,20.731000900268555,22.638999938964844,23.937999725341797,24.628000259399414,24.608999252319336,23.878000259399414,21.323999404907227,20.39699935913086,22.77400016784668,20.923999786376953,19.55900001525879,19.55699920654297,20.260000228881836,20.267000198364258,19.656999588012695,21.670000076293945,21.22599983215332,22.35700035095215,23.545000076293945,24.36199951171875,23.652999877929688,24.003000259399414,25.05699920654297,22.982999801635742,21.775999069213867,20.913999557495117,21.45199966430664,22.429000854492188,18.62700080871582,17.534000396728516,19.409000396728516,18.066999435424805,17.170000076293945,17.572999954223633,18.804000854492188,17.878999710083008,16.937999725341797,19.32200050354004,19.507999420166016,20.93199920654297,21.594999313354492,20.983999252319336,22.87700080871582,23.510000228881836,24.812999725341797,22.865999221801758,21.540000915527344,17.06399917602539,15.717000007629395,17.91200065612793,17.8799991607666,17.31999969482422,18.464000701904297,19.42799949645996,19.236000061035156,18.58300018310547,20.518999099731445,20.69300079345703,21.659000396728516,21.535999298095703,22.61400032043457,23.43600082397461,24.729000091552734,25.37299919128418,25.256999969482422,24.666000366210938,25.38599967956543,23.437999725341797,22.89299964904785,30.70599937438965,26.038999557495117,24.81599998474121,13.442000389099121,15.60200023651123,26.34000015258789,23.514999389648438,24.174999237060547,16.118999481201172,29.19499969482422,25.893999099731445,14.447999954223633,28.150999069213867,31.709999084472656,11.873000144958496,16.604000091552734,17.03499984741211,25.518999099731445,11.354000091552734,29.10300064086914,29.18899917602539,19.14900016784668,9.637999534606934,25.756999969482422,18.861000061035156,19.33799934387207,12.35099983215332,29.900999069213867,30.569000244140625,12.890999794006348,15.741999626159668,32.597999572753906,13.215999603271484,13.814000129699707,25.191999435424805,30.291000366210938,23,27.683000564575195,22.509000778198242,19.143999099731445,12.744000434875488,20.604000091552734,24.586000442504883,19.91699981689453,21.39699935913086,14.428000450134277,23,25.54199981689453,28.68899917602539,22.965999603271484,25.590999603271484,24.374000549316406,28.410999298095703,17.073999404907227,23.826000213623047,11.317999839782715,27.781999588012695,27.410999298095703,28.409000396728516,15.543999671936035,13.161999702453613,11.555999755859375,27.722000122070312,11.432999610900879,10.967000007629395,26.02400016784668,6.413000106811523,5.750999927520752,17.038999557495117,15.890000343322754,23.030000686645508,22.51799964904785,29.488000869750977,11.562999725341797,19.40399932861328,18.315000534057617,25.159000396728516,27.091999053955078,21.69099998474121,31.583999633789062]),
        z: new Float32Array([25.617000579833984,24.2189998626709,24.100000381469727,24.851999282836914,22.694000244140625,22.680999755859375,22.64699935913086,23.944000244140625,24.3799991607666,25.014999389648438,25.214000701904297,25.37700080871582,25.1200008392334,25.444000244140625,24.47100067138672,24.10099983215332,21.482999801635742,21.85099983215332,20.138999938964844,21.49799919128418,22.5939998626709,22.27899932861328,22.673999786376953,20.80699920654297,20.652999877929688,20.416000366210938,21.715999603271484,21.780000686645508,21.429000854492188,21.63599967956543,22.142000198364258,22.545000076293945,22.51799964904785,23.03700065612793,23.155000686645508,23.667999267578125,22.770000457763672,22.27400016784668,19.25200080871582,19.219999313354492,18.114999771118164,19.32699966430664,20.334999084472656,20.2450008392334,20.452999114990234,18.902999877929688,18.92799949645996,18.660999298095703,19.909000396728516,19.520999908447266,19.81599998474121,20.381999969482422,19.50200080871582,18.89699935913086,18.628999710083008,18.570999145507812,18.89900016784668,17.617000579833984,17.764999389648438,16.440000534057617,17.670000076293945,18.753000259399414,18.5049991607666,18.496000289916992,17.176000595092773,17.238000869750977,16.288000106811523,17.218000411987305,16.868999481201172,16.23200035095215,16.07699966430664,16.635000228881836,16.749000549316406,16.368000030517578,17.351999282836914,17.81599998474121,18.35300064086914,17.716999053955078,17.121000289916992,16.2450008392334,16.892000198364258,14.90999984741211,16.160999298095703,17.36199951171875,16.957000732421875,16.56100082397461,15.763999938964844,16.1200008392334,14.696000099182129,15.569000244140625,14.866999626159668,14.381999969482422,13.913000106811523,14.097999572753906,13.819000244140625,13.267999649047852,14.118000030517578,14.668999671936035,14.984000205993652,14.66100025177002,15.062999725341797,15.800000190734863,13.968000411987305,14.479999542236328,15.289999961853027,14.4350004196167,13.961999893188477,13.187000274658203,13.180999755859375,12.060999870300293,12.718999862670898,12.07800006866455,11.868000030517578,11.355999946594238,11.246000289916992,10.8149995803833,10.427000045776367,10.85200023651123,11.272000312805176,11.697999954223633,11.656999588012695,11.914999961853027,12.342000007629395,11.13700008392334,11.076000213623047,11.685999870300293,10.597999572753906,10.279000282287598,9.295999526977539,9.161999702453613,8.222999572753906,9.019000053405762,8.5649995803833,8.175999641418457,8.142999649047852,7.8520002365112305,7.881999969482422,7.61899995803833,8.234999656677246,8.236000061035156,8.593999862670898,7.823999881744385,8.180000305175781,7.159999847412109,6.927000045776367,7.418000221252441,6.438000202178955,6.283999919891357,5.0289998054504395,4.696000099182129,4.138999938964844,5.033999919891357,4.758999824523926,4.49399995803833,4.388999938964844,4.4120001792907715,4.551000118255615,4.502999782562256,4.764999866485596,4.895999908447266,4.9039998054504395,3.2090001106262207,3.2690000534057617,2.4700000286102295,2.6110000610351562,3.249000072479248,2.4570000171661377,2.447999954223633,0.9980000257492065,0.6669999957084656,0.2529999911785126,1.156999945640564,1.0149999856948853,0.8399999737739563,0.6700000166893005,0.8730000257492065,1.0460000038146973,1.0889999866485596,1.1770000457763672,1.1670000553131104,-0.5809999704360962,-0.257999986410141,-0.9470000267028809,-1.7710000276565552,-1.7200000286102295,-2.802000045776367,-2.4040000438690186,-4.188000202178955,-5.214000225067139,-4.185999870300293,-3.5869998931884766,-3.200000047683716,-2.9100000858306885,-2.61299991607666,-2.7179999351501465,-2.510999917984009,-2.178999900817871,-2.7200000286102295,-3.0820000171661377,-3.236999988555908,-3.2669999599456787,-3.061000108718872,-5.980000019073486,-5.048999786376953,-7.164000034332275,-6.366000175476074,-5.317999839782715,-5.510000228881836,-5.396999835968018,-6.8480000495910645,-6.701000213623047,-7.578000068664551,-6.414000034332275,-6.63700008392334,-6.5289998054504395,-6.314000129699707,-6.626999855041504,-6.835999965667725,-6.872000217437744,-6.978000164031982,-6.86899995803833,-7.925000190734863,-7.4079999923706055,-8.758000373840332,-8.762999534606934,-8.359000205993652,-9.298999786376953,-9.138999938964844,-10.8149995803833,-11.401000022888184,-11.380999565124512,-10.269000053405762,-10.265000343322754,-10.477999687194824,-10.390000343322754,-10.10200023651123,-9.855999946594238,-9.857000350952148,-9.625,-9.604999542236328,-9.406000137329102,-9.791999816894531,-10.027000427246094,-9.069999694824219,-9.854000091552734,-9.51200008392334,-9.907999992370605,-8.055000305175781,-7.9039998054504395,-7.60699987411499,-8.836999893188477,-8.944000244140625,-9.005999565124512,-8.932000160217285,-9.192999839782715,-9.333999633789062,-9.58899974822998,-9.27400016784668,-9.079999923706055,-6.501999855041504,-6.664000034332275,-5.49399995803833,-6.177000045776367,-7.156000137329102,-6.6570000648498535,-6.755000114440918,-5.189000129699707,-5.013000011444092,-4.5289998054504395,-5.671000003814697,-5.535999774932861,-5.258999824523926,-5.269000053405762,-5.558000087738037,-5.710000038146973,-5.630000114440918,-5.9730000495910645,-6.10699987411499,-6.324999809265137,-5.986000061035156,-5.7210001945495605,-3.569000005722046,-3.7290000915527344,-2.632999897003174,-3.2079999446868896,-3.996000051498413,-3.5360000133514404,-3.621999979019165,-2.065999984741211,-1.8580000400543213,-1.7280000448226929,-2.871999979019165,-2.427999973297119,-2.558000087738037,-2.9570000171661377,-2.2639999389648438,-1.8250000476837158,-1.5529999732971191,-1.6519999504089355,-1.9789999723434448,-0.4359999895095825,-0.5239999890327454,0.6499999761581421,-0.3630000054836273,-1.2120000123977661,-1.0210000276565552,-1.0479999780654907,0.2930000126361847,0.09700000286102295,1.121000051498413,0.04600000008940697,0.46799999475479126,1.0390000343322754,1.281000018119812,0.8679999709129333,0.8820000290870667,1.2799999713897705,0.4180000126361847,-0.027000000700354576,-0.38199999928474426,-0.07199999690055847,0.3840000033378601,1.3389999866485596,1.024999976158142,2.5380001068115234,1.3899999856948853,0.20000000298023224,0.48399999737739563,0.8159999847412109,1.6330000162124634,1.4110000133514404,2.7909998893737793,2.1449999809265137,2.757999897003174,3.132999897003174,3.5840001106262207,3.48799991607666,3.7860000133514404,4.242000102996826,3.5929999351501465,3.118000030517578,2.7829999923706055,3.002000093460083,2.5260000228881836,1.8880000114440918,3.4260001182556152,3.240999937057495,2.4519999027252197,3.388000011444092,3.8499999046325684,4.614999771118164,4.756999969482422,5.723999977111816,5.243000030517578,5.755000114440918,5.829999923706055,6.276000022888184,6.480000019073486,6.933000087738037,7.243000030517578,7.035999774932861,6.708000183105469,6.264999866485596,6.173999786376953,6.019999980926514,5.581999778747559,6.749000072479248,6.885000228881836,6.302999973297119,7.302000045776367,7.533999919891357,8.668999671936035,8.890999794006348,9.630000114440918,8.798999786376953,9.204999923706055,9.656000137329102,9.802000045776367,9.913000106811523,9.777000427246094,10.029000282287598,9.362000465393066,9.234000205993652,9.04800033569336,10.260000228881836,9.998000144958496,10.840999603271484,11.152999877929688,10.663999557495117,11.678000450134277,11.763999938964844,13.086999893188477,13.553000450134277,13.859999656677246,13.08899974822998,13.204999923706055,13.486000061035156,13.690999984741211,13.496999740600586,13.225000381469727,13.251999855041504,12.932999610900879,12.612000465393066,12.925999641418457,15.015999794006348,14.987000465393066,15.51099967956543,15.83899974822998,15.432999610900879,16.461000442504883,16.26300048828125,17.878999710083008,18.611000061035156,18.4689998626709,17.523000717163086,17.33099937438965,17.32900047302246,17.57900047302246,17.03499984741211,16.73900032043457,16.40399932861328,16.736000061035156,17.03499984741211,20.099000930786133,20.395999908447266,20.305999755859375,20.993000030517578,21.072999954223633,21.976999282836914,21.319000244140625,23.325000762939453,24.292999267578125,22.989999771118164,22.256000518798828,21.542999267578125,21.159000396728516,20.56599998474121,20.579999923706055,20.101999282836914,19.584999084472656,20.308000564575195,20.891000747680664,21.038000106811523,21.350000381469727,21.150999069213867,25.34000015258789,24.62700080871582,26.312000274658203,26.034000396728516,25.309999465942383,25.593000411987305,24.89299964904785,27.05900001525879,27.677000045776367,27.024999618530273,25.56800079345703,25.170000076293945,24.6299991607666,24.503999710083008,24.256999969482422,24.40399932861328,24.01799964904785,24.966999053955078,25.358999252319336,29.246999740600586,29.825000762939453,29.920000076293945,29.284000396728516,28.742000579833984,28.757999420166016,27.82900047302246,30.058000564575195,31.083999633789062,29.577999114990234,28.187999725341797,28.138999938964844,28.579999923706055,28.308000564575195,27.67300033569336,27.117000579833984,27.066999435424805,26.604000091552734,26.57900047302246,26.09600067138672,27.05299949645996,27.56999969482422,18.6560001373291,-8.906000137329102,14.947999954223633,8.571999549865723,-3.388000011444092,-10.581000328063965,18.349000930786133,4.920000076293945,1.2769999504089355,19.861000061035156,15.395999908447266,4.646999835968018,21.61400032043457,20.33099937438965,12.208999633789062,9.965999603271484,1.6720000505447388,-2.052999973297119,9.414999961853027,20.09000015258789,20.392000198364258,13.843999862670898,13.392000198364258,12.98900032043457,12.663999557495117,12.598999977111816,9.406000137329102,-9.281999588012695,18.70199966430664,19.01099967956543,18.593000411987305,15.26200008392334,6.359000205993652,11.704000473022461,-10.298999786376953,27.101999282836914,12.99899959564209,16.368999481201172,9.123000144958496,7.480999946594238,-1.8350000381469727,-9,7.008999824523926,13.380999565124512,11.074999809265137,2.0490000247955322,29.16699981689453,24.44300079345703,16.284000396728516,13.368000030517578,10.82800006866455,9.187999725341797,7.882999897003174,4.809000015258789,1.3960000276565552,-2.9089999198913574,26.49799919128418,9.017000198364258,8.821000099182129,3.8459999561309814,2.2290000915527344,-2.9760000705718994,18.905000686645508,1.0800000429153442,0.26100000739097595,-0.765999972820282,-4.783999919891357,-6.197999954223633,29.792999267578125,-1.3009999990463257,10.331999778747559,9.51099967956543,6.15500020980835,4.511000156402588,-1.090999960899353,14.885000228881836,2.2869999408721924,16.993000030517578,6.802000045776367,4.5960001945495605])
    };
}

// TESTS ---------------------------------------------------------------------------------------------------------------

async function test_set(t, context, args) {
    //const data_short = new Float32Array([5, 5, 7, 9, 2, 4, 6, 0, 7, 5]);
    const data = new Uint32Array(Array.from({length: args[0]}, () => Math.floor(Math.random() * 1000)));
    const b0 = WG.WgBuffer.createStorage(context, [data.length, 1, 1], Uint32Array, data, [WG.BufferFeature.COPIABLE]);
    const b1 = WG.WgBuffer.createOutput(context, [data.length, 1, 1], Uint32Array);
    const shader = new WG.WgCompSetShader(context, b0, 1, b1);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();
    const output = await b1.read();
    t.log("Input: " + formatArray(data));
    t.log("Output: " + formatArray(output));
    t.test(output.length === data.length, "Lengths are the same");
    t.test(output.every(v => v === 1), "All values are one (1)");
}

async function test_gridAssignAndReassign(t, context, args) {
    const components = createComponents();
    const data = createFfrnnData(context, components, true);

    const shader = new WG.WgCompGridAssignShader(context, data.uniforms, data.in_buffers, data.out_buffers);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();
    const out = await Promise.all([
        data.out_buffers.perBin_elemCount.read(),
        data.out_buffers.perElem_binId.read(),
        //data.out_buffers.perElem_xyzcr.read()
    ]);
    const oElemCount = out[0];
    const oBinId = out[1];
    //const oXyzc = out[2];

    t.log("Elem X coordinates: " + formatArray(components.map(v => v.elems).reduce((a,b) => a.concat(b)).map(v => v[0]), 20));
    t.log("Bin X params: min=" + data.uniforms.gridMin.x + ", max=" + data.uniforms.gridMax.x + ", size=" + data.uniforms.gridBinSize.x + ", numBins=" + data.gridShape.x);
    //t.array(oXyzc, "XYZC: ");
    t.array(oElemCount, "Per bin elem counts: ");
    t.log("Per elem bin ID: " + formatArray(oBinId, 20));
    t.matrix(oElemCount, [data.gridShape.x, data.gridShape.y, data.gridShape.z], "Grid: ");
    t.test(oElemCount.length === data.gridSize, "Per bin elem count length is correct (" + data.gridSize + ")");
    t.test(oBinId.length === data.in_buffers.out_perElem_binId.length, "Per elem bin ID length is correct (" + data.in_buffers.out_perElem_binId.length + ")");
    t.test(oElemCount.reduce((a, b) => a || b), "Any value is bigger than 0");

    /*const input2 = {
        perElem_xyzc: data.in_buffers.out_perElem_xyzc,
        out_perBin_elemCount: data.in_buffers.out_perBin_elemCount,
        out_perElem_binId: data.in_buffers.out_perElem_binId
    };
    const compUniforms = {
        oldMatrix_inv: { elements: [1, 0, 0, 0,   0, 1, 0, 0,   0, 0, 1, 0,   -2, -2, -2, 1] },
        newMatrix: { elements:     [1, 0, 0, 0,   0, 1, 0, 0,   0, 0, 1, 0,    3,  3,  2, 1] },
        id: 0
    };
    const output2 = {
        out_perElem_xyzc: data.in_buffers.out_perElem_xyzc.cloneOutput(context),
        out_perBin_elemCount: data.out_buffers.perBin_elemCount,
        out_perElem_binId: data.out_buffers.perElem_binId
    };
    await new WG.WgShaderAlgorithm(context, new WG.WgCompSetShader(context, data.in_buffers.out_perBin_elemCount, 0)).run();
    const shader2 = new WG.WgCompGridReassignShader(context, input2, compUniforms, data.uniforms, output2);
    const algo2 = new WG.WgShaderAlgorithm(context, shader2);
    await algo2.run();
    //await algo2.wait();
    const reassigned = await output2.out_perElem_xyzc.read();
    const elemCount = await output2.out_perBin_elemCount.read();
    const binId = await output2.out_perElem_binId.read();

    //t.log("Reassigned: " + formatVectors(reassigned));
    t.array(reassigned, "Reassigned: ");
    t.array(elemCount, "Elem count: ");
    t.array(binId, "Bin ID: ");
    t.matrix(elemCount, [data.gridShape.x, data.gridShape.y, data.gridShape.z], "Grid: ");*/
}

async function test_scan(t, context, args) {
    const data = new Uint32Array(args[0]).fill(1);

    const workgroupSize = WG.WgCompScanShader.WORKGROUP_SIZE;

    const inputBuffer = WG.WgBuffer.createStorage(context, [data.length, 1, 1], Uint32Array, data, [WG.BufferFeature.COPIABLE]);

    const numWorkgroups = WG.WgCompScanShader.calculateNumWorkgroups(data.length);
    const outputBuffers = {
        perElement_workgroupWisePrefixSum: WG.WgBuffer.createOutput(context, [data.length, 1, 1], Uint32Array),
        perWorkgroup_elementSum: WG.WgBuffer.createOutput(context, [numWorkgroups, 1, 1], Uint32Array),
        perWorkgroup_elementMax: WG.WgBuffer.createOutput(context, [numWorkgroups, 1, 1], Uint32Array)
    }

    const shader = new WG.WgCompScanShader(context, inputBuffer, outputBuffers);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();

    const output1 = await outputBuffers.perElement_workgroupWisePrefixSum.read();
    //const expected = new Uint32Array(args[0]).map((v,i) => i);
    const expected1 = new Uint32Array(data.length).map((v,i) => i % (workgroupSize * 2));

    const wgOutput = await outputBuffers.perWorkgroup_elementSum.read();
    const wgExpected = new Uint32Array(numWorkgroups).fill(WG.WgCompScanShader.WORKGROUP_SIZE * 2);
    const remainder = data.length % (workgroupSize * 2)
    if (remainder > 0) {
        wgExpected[numWorkgroups - 1] = remainder;
    }

    const outputMax = await outputBuffers.perWorkgroup_elementMax.read();
    const expectedMax = new Uint32Array(numWorkgroups).fill(1);

    console.assert(output1.length === expected1.length);
    t.log("Input: " + formatArray(data, 10));
    t.log("First pass output: " + formatArray(output1, 40));
    t.log("First pass expected: " + formatArray(expected1, 40))
    //t.array(data, "Input: ");
    //t.array(output, "Output: ");
    t.test(output1.length === data.length, "Lengths are the same");
    t.test(output1.every((v,i) => v === expected1[i]), "Output and expected are identical");

    t.log("Workgroup sums output: " + formatArray(wgOutput));
    t.log("Workgroup sums expected: " + formatArray(wgExpected));
    t.test(wgOutput.length === wgExpected.length, "Workgroup sums buffer length is " + wgExpected.length);
    t.test(wgOutput.every((v,i) => v === wgExpected[i]), "All workgroup sums are as expected");

    t.log("Computed max: " + formatArray(outputMax));
    t.log("Expected max: " + formatArray(expectedMax));
    t.test(outputMax.every((v,i) => v === expectedMax[i]), "Max is as expected");
}

async function test_add(t, context, args) {
    const data = new Uint32Array([4, 6, 8, 2, 5, 8, 9, 4, 2, 1]);
    const addend = new Uint32Array([2, 9, 1]);
    const b0 = WG.WgBuffer.createStorage(context, [data.length, 1, 1], Uint32Array, data, [WG.BufferFeature.COPIABLE]);
    const b1 = WG.WgBuffer.createOutput(context, [data.length, 1, 1], Uint32Array);
    const shader = new WG.WgCompAddShader(context, b0, addend, undefined, b1);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();
    const output = await b1.read();
    const expected = [6, 8, 10, 4, 14, 17, 18, 13, 3, 2];
    t.log("Input: " + formatArray(data));
    t.log("Addend: " + formatArray(addend));
    t.log("Output: " + formatArray(output));
    t.log("Expected: " + formatArray(expected));
    t.test(output.length === data.length, "Lengths are the same");
    t.test(output.every((v,i) => v === expected[i]), "All values are as expected");
}

async function test_scanAlgorithm(t, context, args) {
    const input = new Float32Array([4, 5, 2, 7, 9, 3, 5, 1, 8, 4]);
    const debug = undefined;//"test_scanAlgorithm";
    const algo = new WG.WgScanAlgorithm(context, input, debug);
    await algo.run();
    //await algo.wait();
    await debugAndDelete(t, debug);
    const output = await algo.readScan();
    const max = await algo.readMax();
    const expected = [0, 4, 9, 11, 18, 27, 30, 35, 36, 44];
    t.log("Input: " + formatArray(input));
    t.log("Output: " + formatArray(output));
    t.log("Expected: " + formatArray(expected));
    t.test(output.every((v,i) => v === expected[i]), "Output is as expected");
    t.log("Computed max: " + max);
    t.log("Expected max: " + 9);
    t.test(max === 9, "Computed max is 9");
}

async function test_gridAssignScan(t, context, args) {
    const components = createComponents();
    const data = createFfrnnData(context, components, false);

    const algo = new WG.WgGridAssignScanAlgorithm(context,
        data.in_buffers.in_perComp_matrix,
        data.in_buffers.in_perElem_xyzcr,
        data.in_buffers.out_perBin_elemCount,
        data.in_buffers.out_perElem_binId,
        data.uniforms.gridMin,
        data.uniforms.gridMax,
        data.uniforms.gridBinSize);

    await algo.run();
    //await algo.wait();
    const output = await algo.read();

    //t.log("Per elem bin ID: " + formatArray(output));
    t.array(output, "Per bin elem count: ");
    t.array(data.expected.perBin_elemCount_scan, "Expected: ");
    t.test(output.every((v,i) => v === data.expected.perBin_elemCount_scan[i]), "Matches expected");
}

async function test_sort_seq(t, context, args) {
    const components = createComponents();
    const data = createFfrnnData(context, components, false);

    const x = data.in_buffers.in_perElem_x;
    const y = data.in_buffers.in_perElem_y;
    const z = data.in_buffers.in_perElem_z;

    const scan = seqScan(data.expected.perBin_elemCount);
    t.log("Per bin elem count: " + formatArray(scan));
    t.log("Expected: " + formatArray(data.expected.perBin_elemCount_scan));
    //t.matrix(data.expected.perBin_elemCount_scan, [data.expected.perBin_elemCount_scan.length, 1, 1], "Scan: ");
    t.test(scan.every((v,i) => v === data.expected.perBin_elemCount_scan[i]), "Matches expected");

    //console.log(data.transformedElems);
    //console.log(data.expected.perElem_binId);
    //console.log(scan);

    const sort = seqCountingSort(data.transformedElems, data.expected.perElem_binId, data.expected.perBin_elemCount);
    //console.log(sort);
    //console.log(data.expected.elems_sortedByBinId);
    t.log("Per elem bin ID: " + formatArray(data.expected.perElem_binId, 20));
    t.test(sort.every((vi,i) => vi.every((vj,j) => vj === data.expected.elems_sortedByBinId[i][j])), "Elems were sorted as expected");
}

async function test_sort_gpu(t, context, args) {
    const components = createComponents();
    const data = createFfrnnData(context, components, false);

    const elemsShape = [data.expected.perElem_binId.length, 1, 1];
    const binsShape = [data.expected.perBin_elemCount.length, 1, 1];
    const sortedInitialized = new Uint32Array(data.expected.perElem_binId.length).fill(0xffffffff);

    const perElem_binId = WG.WgBuffer.createStorage(context, elemsShape, Uint32Array, data.expected.perElem_binId);
    const perBin_elemCount_scan = WG.WgBuffer.createStorage(context, binsShape, Uint32Array, data.expected.perBin_elemCount_scan);
    const perElem_elemId_sorted = WG.WgBuffer.createStorage(context, elemsShape, Uint32Array, sortedInitialized, [WG.BufferFeature.COPIABLE]);
    const bin_maxElemCount = WG.WgBuffer.createStorage(context, [1, 1, 1], Uint32Array, new Uint32Array([data.expected.bin_maxElemCount]));
    const output_perElem_elemId_sorted = WG.WgBuffer.createOutput(context, elemsShape, Uint32Array);

    const in_buffers = {
        perElem_binId: perElem_binId,
        perBin_elemCount_scan: perBin_elemCount_scan,
        bin_maxElemCount: bin_maxElemCount,
        perElem_elemId_sorted: perElem_elemId_sorted
    };

    //const uniforms = {
        //bin_maxElemCount: data.expected.bin_maxElemCount
    //};
    //const uniforms = WG.WgBuffer.createUniform(context, Uint32Array, new Uint32Array([data.expected.bin_maxElemCount]));

    const shader = new WG.WgCompSortShader(in_buffers, output_perElem_elemId_sorted);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();
    const output = await output_perElem_elemId_sorted.read();

    const output_sorted = new Array(output.length);
    for (let i = 0; i < output.length; ++i) {
        const v = output[i];
        output_sorted[i] = data.transformedElems[v];
    }

    //t.log("Expected: " + formatArray(data.expected));
    t.log("Sorted elem IDs: " + formatArray(output));

    t.log("Output sorted elems XYZ: " + formatVectors(output_sorted));
    t.log("Expected sorted elems XYZ: " + formatVectors(data.expected.elems_sortedByBinId));
    t.test(data.expected.elems_sortedByBinId.every((vi,i) =>  vi.every((vj, j) => output_sorted[i][j])), "Sorted elems are as expected");
}

async function test_map_xyz(t, context,args) {
    const xyzi =           [7, 2, 8, 5, 4, 1, 9, 0, 6, 3];
    const comps =          [0, 0, 0, 1, 1, 1, 1, 1, 2, 2];
    const xyzcr = xyzi.map((v,i) => [v, v, v, (comps[i] << 16) | 50]).reduce((a,b) => a.concat(b));
    //const expected =       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    const expected =       [0, 8, 6, 1, 4, 2, 3, 7, 9, 5];
    const expected_comps = [1, 1, 0, 2, 1, 1, 2, 0, 0, 1];

    const shape = [xyzi.length, 1, 1];
    const shape4 = [4, xyzi.length, 1, 1];

    const inputs = {
        indices: WG.WgBuffer.createStorage(context, shape, Uint32Array, new Uint32Array(xyzi)),
        in_xyzcr: WG.WgBuffer.createStorage(context, shape4, Float32Array, new Float32Array(xyzcr)),
        out_xyzcr: WG.WgBuffer.createEmptyStorage(context, shape4, Float32Array, [WG.BufferFeature.COPIABLE]),
    };

    const outputs = {
        xyzcr: WG.WgBuffer.createOutput(context, shape4, Float32Array)
    };

    const shader = new WG.WgCompMapXyzShader(inputs, outputs);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();

    const out_xyzc = await outputs.xyzcr.read();
    const outx = out_xyzc.filter((v,i) => i % 4 === 0);

    //t.log("Input: " + formatVectors(xyzc));
    t.log("Input X: " + formatArray(xyzi));
    t.log("Output X: " + formatArray(outx));
    t.log("Expected X: " + formatArray(expected));
    t.test(outx.every((v,i) => v === expected[i]), "Output matches expected");
}

async function test_collision_global(t, context, args) {
    const comps = createComponents();
    const data = createData(comps);

    //const xyzc = new Float32Array(data.xyzc.reduce((a,b) => a.concat(b)));
    const xyzcr = new Float32Array(data.xyzc_sorted
        .map(v => {
            const compi = v[3];
            const x = compi === 0 ? 2 : 0;
            const y = compi === 0 ? 2 : -4;
            const z = compi === 0 ? 2 : 0;
            //return [v[0] - x, v[1] - y, v[2] - z, compi];
            return [v[0], v[1], v[2], compi];
        })
        .reduce((a,b) => a.concat(b)));
    for (let i = 0; i < data.elems.length; ++i) {
        const j = (i * 4) + 3;
        const compi = xyzcr[j];
        new Uint32Array(xyzcr.buffer, j * 4, 1).set([(compi << 16) | (data.elemRadius * 100)]);
    }

    const collisions = new WG.BitArray(data.elems.length);

    const matrices = new Float32Array(comps.map(v => v.matrix.elements).reduce((a,b) => a.concat(b)));

    const input = {
        in_xyzcr: WG.WgBuffer.createStorage(context, [4, data.elems.length, 1], Float32Array, xyzcr),
        in_perComp_matrix: WG.WgBuffer.createStorage(context, [matrices.length, 1, 1], Float32Array, matrices),
        in_perBinElemCount_scan: WG.WgBuffer.createStorage(context, [data.expected.perBin_elemCount_scan.length, 1, 1], Uint32Array, data.expected.perBin_elemCount_scan),
        out_collisions: WG.WgBuffer.createEmptyStorage(context, [collisions.raw.length, 1, 1], Uint32Array, [WG.BufferFeature.COPIABLE])
    };

    const uniforms = {
        gridMin: data.gridMin,
        gridMax: data.gridMax,
        gridBinSize: data.gridBinSize,
        //elemRadius: data.elemRadius
    };

    const output = {
        collisions: WG.WgBuffer.createOutput(context, [collisions.raw.length, 1, 1], Uint32Array)
    };

    const shader = new WG.WgCompCollisionGlobalShader(context, input, uniforms, output);
    const algo = new WG.WgShaderAlgorithm(context, shader);
    await algo.run();
    //await algo.wait();
    const out_raw = await output.collisions.read();
    const out = new WG.BitArray(collisions.length, out_raw);

    t.log("Grid shape: (" + data.gridShape.x + "," + data.gridShape.y + "," + data.gridShape.z + ")");
    //t.log("X values (sorted): " + formatArray(data.xyzc_sorted.map(v => v[0])));
    t.log("XYZC (sorted): " + formatVectors(data.xyzc_sorted, undefined, undefined, 20));
    t.array(xyzcr, "XYZCR (sorted): ");
    t.log("Bin IDs (sorted): " + formatArray(data.expected.perElem_binId.sort()));
    t.log("Bin elem count scan: " + formatArray(data.expected.perBin_elemCount_scan));
    t.log("Output raw: " + formatArray(out_raw));
    t.log("Output: " + out.toString());
    t.log("Expected: " + data.expected.elems_collisions_sorted.toString());
    t.test(data.expected.elems_collisions_sorted.equals(out), "Output matches expected");
    t.test(!out.get(0), "0th element does NOT collide");
    t.test(out.get(3), "3rd element collides");
    t.test(out.get(4), "4th element collides");
    t.test(out.get(6), "6th element collides");
    t.test(!out.get(7), "7th element does NOT collide");
}

async function test_bitArray(t, context, args) {
    const length = 8;
    const bits = [0, 1, 1, 0, 0, 1, 0, 1];
    console.assert(bits.length === length);

    //const catana = new BitArray(length, bits);
    const catana = WG.BitArray.convert(bits);

    const legacy = new WG.BitArray_Legacy(length);
    for (let i = 0; i < length; ++i) {
        if (bits[i] !== 0) legacy.set(i);
    }

    t.log("Catana: " + catana.toString() + " (" + catana.length + ")");
    t.log("Legacy: " + legacy.toString() + " (" + legacy.length + ")");

    t.log("Catana raw: " + formatArray(catana.raw));
    t.log("Legacy raw: " + formatArray(legacy.raw));

    t.log("Test each of the 8 bits:");
    for (let i = 0; i < length; ++i) {
        const bit = bits[i] !== 0;
        const c = catana.get(i);
        const l = legacy.get(i);
        t.test(bit === c && c === l, "Bit " + i + ": C=" + c + " and L=" + l + " should be " + bit);
    }

    // Split
    {
        // Length = 32 * 3 = 96
        const a = WG.BitArray.convert([1, 1, 0, 0, 1, 1, 1, 1,
                                             1, 0, 0, 0, 0, 1, 1, 0,
                                             1, 0, 0, 1, 1, 1, 0, 1,
                                             0, 1, 1, 0, 0, 1, 1, 0,

                                             0, 1, 1, 1, 1, 0, 0, 1,
                                             0, 1, 0, 0, 0, 1, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 0, 1, 1, 1, 1, 0,

                                             0, 0, 0, 0, 0, 0, 1, 0,
                                             0, 0, 0, 1, 0, 0, 1, 1,
                                             0, 0, 1, 1, 1, 1, 1, 0,
                                             0, 0, 1, 0, 0, 1, 1, 0]);

        t.log("Input: " + a.toString());

        const b = a.slice(88);
        t.log("slice(88): " + b.toString());
        t.test(b.length === 8, "slice(88) length is 8");
        t.test(b.equals(WG.BitArray.convert([0, 0, 1, 0, 0, 1, 1, 0])), "slice(88) is 00100110");

        const c = a.slice(40, 50);
        t.log("slice(40,50): " + c.toString());
        t.test(c.length === 10, "slice(40,50) length is 10");
        t.test(c.equals(WG.BitArray.convert([0, 1, 0, 0, 0, 1, 1, 1, 1, 1])), "slice(40,50) is 0100011111");

        const d = a.slice(3, 40);
        t.log("slice(3,40): " + d.toString());
        t.test(d.length === 37, "slice(3,40) length is 37");
        t.test(d.equals(WG.BitArray.convert([         0, 1, 1, 1, 1,
                                                   1, 0, 0, 0, 0, 1, 1, 0,
                                                   1, 0, 0, 1, 1, 1, 0, 1,
                                                   0, 1, 1, 0, 0, 1, 1, 0,

                                                   0, 1, 1, 1, 1, 0, 0, 1])), "slice(3,40) is 01111100001101001110101100110011 11001");

        t.test(!a.is0(), "BitArray is not all zeros");
        t.test(new WG.BitArray(300).is0(), "New bit array of length 300 is all zeros");
        t.test(a.is0(2,4), "is0(2,4) is true");
        t.test(!a.is0(2,5), "is0(2,5) is false");
        t.test(a.is0(63, 70), "is0(63,70) is true");
        t.test(a.is0(95), "is0(95) is true");
        t.test(!a.is0(94), "is0(94) is false");
    }
}

async function test_collision_global_algorithm(t, context, args) {
    const comps = createComponents();
    //const data = createData(comps);
    const data = createFfrnnData(context, comps);

    const objs = [];
    for (const c of comps) {
        objs.push({
            c: c,
            x: new Float32Array(c.elems.map(v => v[0])),
            y: new Float32Array(c.elems.map(v => v[1])),
            z: new Float32Array(c.elems.map(v => v[2]))
        });
    }

    const debug = undefined;//"test_collision_global_algorithm";

    //const algo = await WG.WgCollisionAlgorithm.create(context, objs, data.uniforms.elemRadius, true, debug);
    const algo = new WG.WgCollisionAlgorithm(context, objs, data.uniforms.elemRadius, debug);
    await algo.start();
    //await algo.wait();
    await debugAndDelete(t, debug);
    //await algo.collideGlobal().wait();
    const out_raw = await algo.read();
    const out = new WG.BitArray(data.xyzc.length, out_raw);

    t.log("Output raw: " + formatArray(out_raw));
    t.log("Output: " + out.toString());
}

async function test_unsort(t, context, args) {
    //                                   0  1  2  3  4  5  6  7  8  9
    const sort_in = WG.BitArray.convert([0, 0, 0, 1, 1, 0, 0, 1, 0, 1]);
    const indices = [9, 6, 2, 8, 1, 0, 4, 3, 7, 5];
    const sort_out = WG.BitArray.convert([1, 0, 0, 0, 0, 0, 1, 1, 1, 0]);

    const unsort_in = sort_out.clone();
    const unsort_out = sort_in.clone();

    const shape = [10, 1, 1];
    const shape32 = [1, 1, 1];
    const bIN  = WG.WgBuffer.createStorage(context, shape32, Uint32Array, unsort_in.raw, [WG.BufferFeature.COPIABLE]);
    const bID  = WG.WgBuffer.createStorage(context, shape, Uint32Array, new Uint32Array(indices));
    const bOUT = WG.WgBuffer.createStorage(context, shape32, Uint32Array, new Uint32Array([0]), [WG.BufferFeature.COPIABLE]);

    // SORT
    /*const input = {
        perElem_binId: bIN,
        perBin_elemCount_scan: bID,
        bin_maxElemCount: bONE,
        perElem_elemId_sorted: bOUT
    };
    const output = WG.WgBuffer.createOutput(context, shape32, Uint32Array);
    const sort = new WG.WgCompSortShader(context, input, output);
    const algo_sort = WG.WgAlgorithm.fromCompShader(context, sort);
    await algo_sort.run();
    // await algo_sort.wait();
    const sort_output = WG.BitArray.convert(await output.read());
    t.array(sort_output.raw, "SORT output (raw): ");
    t.log("SORT output: " + sort_output.toString());*/

    // UNSORT
    const input = {
        in_collisions: bIN,
        indices: bID,
        out_collisions: bOUT
        /*
            in_collisions: WgBuffer<Uint32Array>;
            indices: WgBuffer<Uint32Array>;
            out_collisions: WgBuffer<Uint32Array>;
         */
    };
    const output = WG.WgBuffer.createOutput(context, shape32, Uint32Array);
    const unsort = new WG.WgCompUnsortShader(input, output);
    const algo_unsort = new WG.WgShaderAlgorithm(context, unsort);
    await algo_unsort.run();
    //await algo_unsort.wait();
    const unsort_output = new WG.BitArray(10, await output.read());

    t.log("Expected output: " + unsort_out.toString() + " (raw: " + formatArray(unsort_out.raw) + ")");
    t.log("Actual output: " + unsort_output.toString() + " (raw: " + formatArray(unsort_output.raw) + ")");
    t.test(unsort_out.equals(unsort_output), "Output is as expected");
}

async function test_collision_algorithm(t, context, args) {

    const matrix = (elements) => {
        return {
            elements: elements,
            clone: () => matrix(elements)
        };
    };

    const c1Box = { min: new WG.Vector3(2.621999979019165, 5.750999927520752, -11.401000022888184), max: new WG.Vector3(28.496000289916992, 34.19499969482422, 31.083999633789062) };
    const c2Box = { min: new WG.Vector3(14.059374003496352, 28.217258281954074, 23.248159782429134), max: new WG.Vector3(39.93337431439418, 56.66125804925754, 65.73315943910637) };

    const _1bna = data_1bna();

    const comps = [
        { // Component 1
            c: {
                name: "COMP_test_collision_algorithm",
                matrix: matrix([1, 0, 0, 0,
                                        0, 1, 0, 0,
                                        0, 0, 1, 0,
                                        0, 0, 0, 1]),
                getBox: () => c1Box
            },
            x: _1bna.x,
            y: _1bna.y,
            z: _1bna.z
        },
        { // Component 2
            c: {
                name: "COMP_2",
                matrix: matrix([1, 0, 0, 0,
                                        0, 1, 0, 0,
                                        0, 0, 1, 0,
                                        11.43737, 22.46625, 34.64915, 1]),
                getBox: () => c2Box
            },
            x: _1bna.x,
            y: _1bna.y,
            z: _1bna.z
        }
    ];

    const debug = "test_collision_algorithm (ultimate)";
    //const algo = await WG.WgCollisionAlgorithm.create(context, 0.5, comps, debug);
    const algo = new WG.WgCollisionAlgorithm(context, comps, 0.5, debug);
    await algo.start();
    //await algo.wait();
    const bitArray = await algo.readAsBitArray();
    t.log(bitArray.toString());
    t.log("Comp1: " + bitArray.slice(0, _1bna.x.length).toString());
    t.log("Comp2: " + bitArray.slice(_1bna.x.length).toString());

    WG.WgPass.printOutputs(debug);
}

async function test_performance(t, context, args, barChart) {
    args = args.slice();
    const size = args.shift();

    const gpuColor = "LightCoral";
    const cpuColor = "LightSkyBlue";
    if (!barChart) {
        barChart = new VisBarChart();
        barChart.addLegend("GPU", gpuColor);
        barChart.addLegend("CPU", cpuColor);
        t.show("Performance: ", barChart.container);
    }

    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice({
        requiredFeatures: ["timestamp-query"]
    });

    const data = new Float32Array(size);
    const gpuBuffer = device.createBuffer({
        mappedAtCreation: true,
        size: data.byteLength,
        usage: GPUBufferUsage.STORAGE
    });
    new Float32Array(gpuBuffer.getMappedRange()).set(data);
    gpuBuffer.unmap();

    const value = 69420;
    const workgroupSize = 256;

    const shaderCode =
        "@group(0) @binding(0) var<storage, write> data: array<f32>;\n" +
        "@stage(compute) @workgroup_size(" + workgroupSize + ")\n" +
        "fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n" +
        "    // Guard against out-of-bounds work group sizes\n" +
        "    if (global_id.x >= u32(arrayLength(&data))) {\n" +
        "        return;\n" +
        "    }\n" +
        "    data[global_id.x] = " + value + "f;\n" +
        "}";
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });

    const computePipeline = device.createComputePipeline({
        //layout: "auto",
        compute: {
            module: shaderModule,
            entryPoint: "main"
        }
    });

    const bindGroup = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [{
            binding: 0,
            resource: { buffer: gpuBuffer }
        }]
    });

    const queriesCount = 2;
    const queriesSize = 2 * (Uint32Array.BYTES_PER_ELEMENT * 2);
    const querySet = device.createQuerySet({
        type: "timestamp",
        count: queriesCount
    });
    const queryBuffer = device.createBuffer({
        size: queriesSize,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    const queryMapBuffer = device.createBuffer({
        size: queriesSize,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });

    const commandEncoder = device.createCommandEncoder();

    // Pass 1
    commandEncoder.writeTimestamp(querySet, 0);

    // Pass 2
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(computePipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.dispatch(Math.ceil(data.length / workgroupSize));
    passEncoder.end();

    // Pass 3
    commandEncoder.writeTimestamp(querySet, 1);

    // Pass 4
    commandEncoder.resolveQuerySet(querySet, 0, 2, queryBuffer, 0);

    // Pass 5
    commandEncoder.copyBufferToBuffer(queryBuffer, 0, queryMapBuffer, 0, queriesSize);

    const commandBuffer = commandEncoder.finish();
    device.queue.submit([commandBuffer]);
    const promiseGpu = queryMapBuffer.mapAsync(GPUMapMode.READ).then(() => {
        const times = new BigUint64Array(queryMapBuffer.getMappedRange())
        const gpuElapsed = Number(times[1] - times[0]) / 1000000; // nanoseconds to milliseconds
        queryMapBuffer.unmap();
        return gpuElapsed;
    });

    const cpuStart = performance.now();
    for (let i = 0; i < data.length; ++i) {
        data[i] = value;
    }
    const cpuElapsed = performance.now() - cpuStart;

    promiseGpu.then((gpuElapsed) => {
        //t.log("GPU elapsed: " + gpuElapsed + " ms");
        //t.log("CPU elapsed: " + cpuElapsed + " ms");
        barChart.addData({
            value: gpuElapsed,
            color: gpuColor,
            text: gpuElapsed.toFixed(3) + "ms\n(" + size + ")"
        });
        barChart.addData({
            value: cpuElapsed,
            color: cpuColor,
            text: cpuElapsed.toFixed(3) + "ms\n(" + size + ")"
        });
        if (args.length > 0) {
            barChart.addSpace();
            test_performance(t, context, args, barChart);
        }
    });
}

async function test_rendering(t, webGpuContext, args) {
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const width = 500;
    const height = 500;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const canvasContext = canvas.getContext("webgpu");
    const format = canvasContext.getPreferredFormat(adapter);
    canvasContext.configure({
        device, format, size: [width, height]
    });

    const camMat = new WG.Matrix4().set(1, 0, 0, 0,
                                        0, 1, 0, 0,
                                        0, 0, 1, 100,
                                        0, 0, 0, 1);
    const camera = new WG.PerspectiveCamera(2 * Math.PI / 5, width / height, 0.1, 1000);

    const createUniformsData = () => {
        const right4 = new WG.Vector4(1, 0, 0, 0).applyMatrix4(camMat);
        const up4 = new WG.Vector4(0, 1, 0, 0).applyMatrix4(camMat);
        const viewProj = new WG.Matrix4().getInverse(camMat).premultiply(camera.projectionMatrix);
        return new Float32Array([
            ...viewProj.elements,                                      // view projection matrix
            ...new WG.Vector3(right4.x, right4.y, right4.z).toArray(), // right
            inputRadius.value,                                         // radius
            ...new WG.Vector3(up4.x, up4.y, up4.z).toArray()           // up
        ]);
    };


    const rend = renderer(canvas, camMat, camera,() => {
        const data = createUniformsData();
        /*const right = new WG.Vector3(data[20], data[21], data[22]);
        const up = new WG.Vector3(data[16], data[17], data[18]);
        const rightLength = right.length();
        const upLength = up.length();
        const angle = right.angleTo(up) * 180 / Math.PI;*/
        device.queue.writeBuffer(bufferUniforms, 0, data);
        draw();
    });
    const inputRadius = document.createElement("input");
    inputRadius.type = "number";
    inputRadius.step = 0.01;
    inputRadius.value = 0.12;
    inputRadius.addEventListener("input", () => {
        device.queue.writeBuffer(
            bufferUniforms,
            Float32Array.BYTES_PER_ELEMENT * (16 + 3),
            new Float32Array([inputRadius.value]));
        draw();
    });
    const label = document.createElement("span");
    label.textContent = "Radius";
    const div = document.createElement("div")
    div.className = "params";
    div.appendChild(label);
    div.appendChild(inputRadius);
    rend.controls.appendChild(div);
    t.show("Rendering: ", rend.container);

    const points = new Float32Array([
        -0.5, 0.5, 0,
        0.5, -0.5, 0,
        -0.5, -0.5, 0,
        0.5, 0.5, 0,
        0, 0, 0
    ]);

    const offsets = new Float32Array([
        1, 1,
        -1, 1,
        1, -1,
        -1, -1,
    ]);

    const bufferPoints = device.createBuffer({
        size: points.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
    });
    new Float32Array(bufferPoints.getMappedRange()).set(points);
    bufferPoints.unmap();

    const bufferOffsets = device.createBuffer({
        size: offsets.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
    });
    new Float32Array(bufferOffsets.getMappedRange()).set(offsets);
    bufferOffsets.unmap();

    const uniforms = createUniformsData();
    const bufferUniforms = device.createBuffer({
        size: uniforms.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
    });
    new Float32Array(bufferUniforms.getMappedRange()).set(uniforms);
    bufferUniforms.unmap();

    const shaderCode = await getShader("rendering");
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });

    const draw = () => {

        const renderPipeline = device.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: shaderModule,
                entryPoint: "vs_main",
                buffers: [
                    {
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,
                        stepMode: "instance",
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x3"
                            }
                        ]
                    },
                    {
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x2"
                            }
                        ]
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "fs_main",
                targets: [
                    {
                        format: format,
                        // TODO blend?
                    }
                ]
            },
            primitive: {
                topology: "triangle-strip"
            }
            // TODO depth stencil?
        });

        const renderPassDescriptor = {
            colorAttachments: [
                {
                    view: canvasContext.getCurrentTexture().createView(),
                    clearValue: { r: 0.9, g: 0.8, b: 0.9, a: 1.0 },
                    loadOp: "clear",
                    storeOp: "store"
                }
            ]
        };

        const bindGroupUniforms = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: bufferUniforms
                    }
                }
            ]
        });

        const commandEncoder = device.createCommandEncoder();
        const renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPassEncoder.setPipeline(renderPipeline);
        renderPassEncoder.setBindGroup(0, bindGroupUniforms);
        renderPassEncoder.setVertexBuffer(0, bufferPoints);
        renderPassEncoder.setVertexBuffer(1, bufferOffsets);
        renderPassEncoder.draw(4, Math.round(points.length / 3));
        renderPassEncoder.end();
        device.queue.submit([commandEncoder.finish()]);
    };
    draw();
}