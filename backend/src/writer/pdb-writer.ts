/**
 * @file Pdb Writer
 * @author Alexander Rose, improved by David Kutak
 * @private
 */

import { sprintf } from 'sprintf-js'

import Writer from './writer'
import { defaults, ensureArray } from '../utils'
import Structure from '../structure/structure'
import AtomProxy from '../proxy/atom-proxy'
import { Assembly } from '../catana'

// http://www.wwpdb.org/documentation/file-format

// Sample PDB line, the coords X,Y,Z are fields 5,6,7 on each line.
// ATOM      1  N   ARG     1      29.292  13.212 -12.751  1.00 33.78      1BPT 108

const AtomFormat =
  'ATOM  %5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s'

const HetatmFormat =
  'HETATM%5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s'

const TerFormat =
  'TER   %5d      %3s %1s%4d                                         '

export interface PdbWriterParams {
  renumberSerial: boolean
  remarks: string[]
}

/**
 * Create a PDB file from a Structure object
 */
export default class PdbWriter extends Writer {
  readonly mimeType = 'text/plain'
  readonly defaultName = 'structure'
  readonly defaultExt = 'pdb'

  renumberSerial: boolean
  remarks: string[]

  structure: Structure
  private _records: string[]

  /**
   * @param  {Structure} structure - the structure object
   * @param  {Object} params - parameters]
   */
  constructor(structure: Structure, params?: PdbWriterParams) {
    super()

    const p = Object.assign({}, params)

    this.renumberSerial = defaults(p.renumberSerial, true)
    this.remarks = ensureArray(defaults(p.remarks, []))

    this.structure = structure
    this._records = []
  }

  private _writeRecords() {
    this._records.length = 0

    this._writeTitle()
    this._writeRemarks()
    this._writeAtoms()
  }

  private _writeTitle() {
    // FIXME multiline if title line longer than 80 chars
    this._records.push(sprintf('TITLE %-74s', this.structure.name))
  }

  private _writeRemarks() {
    this.remarks.forEach(str => {
      this._records.push(sprintf('REMARK %-73s', str))
    })

    if (this.structure.trajectory) {
      this._records.push(sprintf(
        'REMARK %-73s',
        "Trajectory '" + this.structure.trajectory.name + "'"
      ))
      this._records.push(sprintf(
        'REMARK %-73s',
        `Frame ${(this.structure.trajectory as any).frame}`  // TODO
      ))
    }

    // Exporting assembly remarks
    let biomolecules: Assembly[] = [];

    if (this.structure.biomolDict) {
      for (let assembly in this.structure.biomolDict) {
        if (assembly.startsWith("BU")) {
          const bmol = this.structure.biomolDict[assembly];

          if (bmol.partList.length > 0 && bmol.partList[0].chainList.length > 0 &&
            bmol.partList[0].matrixList.length > 0) {
            biomolecules.push(bmol);
          }
        }
      }
    }

    if (biomolecules.length > 0) {
      const bioNrs = biomolecules.map((val, idx) => idx + 1).join(", ");

      this._records.push("REMARK 300                                                                      ");
      this._records.push("REMARK 300 BIOMOLECULE: " + sprintf("%-56s", bioNrs));
      this._records.push("REMARK 300 SEE REMARK 350 FOR THE AUTHOR PROVIDED AND/OR PROGRAM                ");
      this._records.push("REMARK 300 GENERATED ASSEMBLY INFORMATION FOR THE STRUCTURE IN                  ");
      this._records.push("REMARK 300 THIS ENTRY.  THE REMARK MAY ALSO PROVIDE INFORMATION ON              ");
      this._records.push("REMARK 300 BURIED SURFACE AREA.                                                 ");

      this._records.push("REMARK 350                                                                      ");
      this._records.push("REMARK 350 GENERATING THE BIOMOLECULE                                           ");
      this._records.push("REMARK 350 COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN           ");
      this._records.push("REMARK 350 BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE                ");
      this._records.push("REMARK 350 MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS          ");
      this._records.push("REMARK 350 GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND                          ");
      this._records.push("REMARK 350 CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.                               ");
      this._records.push("REMARK 350                                                                      ");

      for (let i = 0; i < biomolecules.length; ++i) {
        this._records.push("REMARK 350 BIOMOLECULE: " + sprintf("%-56s", i + 1));

        // TODO Only the first part is processed currently
        //      More parts would probably mean generating more "APPLY THE FOLLOWING ..."
        //      records per one biomolecule as well as more BIOMT (2, 3, ..) transformations?
        const part = biomolecules[i].partList[0];

        // Around eight to nine chain names seem to be usually used per line
        for (let i = 0; i < part.chainList.length; i += 8) {
          let currChainNames: string[] = [];

          for (let j = i; j < Math.min(part.chainList.length, i + 8); ++j) {
            currChainNames.push(part.chainList[j]);
          }

          let namesString = currChainNames.join(", ");
          const remarkTitle = i === 0 ?
            "REMARK 350 APPLY THE FOLLOWING TO CHAINS: " :
            "REMARK 350                    AND CHAINS: ";

          this._records.push(remarkTitle + sprintf("%-38s", namesString));
        }

        // Output matrix transformation
        // Transpose is here since the elements are stored in column major order but 
        // it is more user-friendly to access them in row-major order in this case
        const matrix = part.matrixList[0].clone().transpose().elements;
        this._records.push("REMARK 350   BIOMT1   1  " + sprintf("%1.6f  %1.6f  %1.6f        %1.6f           ", matrix[0], matrix[1], matrix[2], matrix[3]));
        this._records.push("REMARK 350   BIOMT2   1  " + sprintf("%1.6f  %1.6f  %1.6f        %1.6f           ", matrix[4], matrix[5], matrix[6], matrix[7]));
        this._records.push("REMARK 350   BIOMT3   1  " + sprintf("%1.6f  %1.6f  %1.6f        %1.6f           ", matrix[8], matrix[9], matrix[10], matrix[11]));

        if (i != biomolecules.length - 1) {
          this._records.push("REMARK 350                                                                     ");
        }
      }
    }
  }

  private _writeAtoms() {
    let ia = 1
    let im = 1
    let terRecordsFound = 0;

    this.structure.eachModel(m => {
      this._records.push(sprintf('MODEL %-74d', im++))

      m.eachAtom((a: AtomProxy) => {
        const formatString = a.hetero ? HetatmFormat : AtomFormat
        let serial = (this.renumberSerial ? ia : a.serial) + terRecordsFound;

        // Maximum number of atoms in PDB is 99,999
        serial = serial % 100000;
        // Maximum sequence number in PDB is 9,999
        let resno = a.resno % 10000;

        // Alignment of one-letter atom name such as C starts at column 14,
        // while two-letter atom name such as FE starts at column 13.
        let atomname = a.atomname
        if (atomname.length === 1) atomname = ' ' + atomname

        this._records.push(sprintf(
          formatString,

          serial,
          atomname,
          a.resname,
          defaults(a.chainname, ' '),
          resno,
          a.x, a.y, a.z,
          defaults(a.occupancy, 1.0),
          defaults(a.bfactor, 0.0),
          '',  // segid
          defaults(a.element, '')
        ))

        // If this is the last atom of this residue and 
        // the last residue of this chain, insert TER record
        if (a.index === a.residue.atomEnd &&
          a.residue.index === a.residue.chain.residueEnd) {
          this._records.push(sprintf(
            TerFormat,

            serial + 1,
            a.resname,
            defaults(a.chainname, ' '),
            resno,
          ));

          ++terRecordsFound;
        }

        ia += 1
      }, this.structure.getFilter())

      this._records.push(sprintf('%-80s', 'ENDMDL'))
      im += 1
    })

    this._records.push(sprintf('%-80s', 'END'))
  }

  /**
   * Get string containing the PDB file data
   * @return {String} PDB file
   */
  getData() {
    this._writeRecords()
    return this._records.join('\n')
  }
}
