import ModalBox from "./modal-box";
import TabsMenu from "../complex/tabs-menu";
import Element, { CallbackType } from "../element";
import Panel, { PanelOrientation } from "../panel";
import { IconText, IconType } from "../icon";
import { SequenceEditor } from "../specialized/sequence-editor";
import Button from "../button";
import CATANA from "../../catana-instance";
import { BDnaIdealisticForm, BDnaForm, DnaForm, AtomGenerationLimit, Log } from "catana-backend";
import Select from "../select";
import TextElement from "../text-element";
import Input from "../input";

class StrucConfigModal extends ModalBox {
    public constructor(icon?: IconType) {
        super("Structure configurations", false, icon);
        this.add(new TabsMenu()
            .addTab("DNA geometry", StrucConfigModal.createDnaFormElement())
            .addTab("Default sequence", StrucConfigModal.createDefSeqElement())
            .addTab("Atom generation", StrucConfigModal.createAtomGenerationElement(this)));
    }

    private static createDnaFormElement(): Element {
        const dnaForms: [DnaForm, string, string][] = [
            [BDnaIdealisticForm, "Idealistic B-DNA", "Default Catana DNA geometry. Well-supported by all of Catana features."],
            [BDnaForm, "B-DNA (Experimental)", "DNA geometry with more realistic B-DNA parameters, resulting in more significant major and minor grooves, for example." +
                " Support of this geometry is in an experimental stage, and some Catana features (e.g., UNF import and DNA strand extension) may not behave well with it." +
                " However, this geometry is well-suited for ssDNA and dsDNA created from scratch."]
        ];

        const dnaFormSelect = new Select(dnaForms.map(x => x[1]));
        dnaFormSelect.addCallback(CallbackType.CHANGE, () => {
            for (let i = 0; i < dnaForms.length; ++i) {
                const currForm = dnaForms[i];
                if (currForm[1] === dnaFormSelect.getSelectedOptions()[0].value) {
                    CATANA.CatanaState.dnaFactory.dnaForm = currForm[0];
                    dnaFormDescription.setText(currForm[2]);
                }
            }
        });

        const dnaFormDescription = new TextElement(dnaForms[0][2]);

        return new Panel(PanelOrientation.VERTICAL).add(dnaFormSelect, dnaFormDescription);
    }

    private static createDefSeqElement(): Element {
        const text = new IconText(IconType.DNA)
            .t("Input the default FASTA sequence to be used when creating and modifying coarse-grained DNA strands.")
            .br()
            .t(" If no sequence is set, a random sequence will be generated.");
        const editor = new SequenceEditor(true, true, false, true);
        const button = new Button("Confirm sequence").addCallback(CallbackType.CLICK, () => {
            const sequence: string = editor.getSequence();
            if (sequence.length === 0) {
                CATANA.Log.error("Invalid characters in FASTA sequence! Random sequence will be used.");
                CATANA.CatanaState.dnaFactory.sequenceProvider = new CATANA.RandomNaSequenceProvider();
            } else {
                CATANA.Log.info("Sequence successfully set!");
                CATANA.CatanaState.dnaFactory.sequenceProvider = new CATANA.FastaSequenceProvider(sequence);
            }
        });
        return new Panel(PanelOrientation.VERTICAL).add(text, editor, button);
    }

    private static createAtomGenerationElement(parent: ModalBox): Element {
        const text = new TextElement("Set the maximum number of atoms that can be generated by Catana.")
            .br()
            .t("Keep in mind that:")
            .br()
            .t("1) PDB does not officially allow more than 99,999 atoms in a single model")
            .br()
            .b("2) Generating large number of atoms may take a very long time and/or cause Catana to freeze!");

        const maximumInput = new Input(AtomGenerationLimit.getMaximum().toString(), "number");

        const setButton = new Button("Set new limit").addCallback(CallbackType.CLICK, () => {
            const newLim = Number.parseInt(maximumInput.getValue());

            if (newLim >= 0) {
                AtomGenerationLimit.setNewMaximum(newLim);
                Log.info("New atom generation limit set: " + newLim);
            } else {
                Log.warn("Limit cannot be negative!");
            }
        });

        parent.addOnShowCallback(() => {
            maximumInput.setValue(AtomGenerationLimit.getMaximum().toString());
        });

        return new Panel(PanelOrientation.VERTICAL).add(text, maximumInput, setButton);
    }
}

export default StrucConfigModal;